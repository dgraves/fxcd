/* CDInfo.h
 * Copyright (C) 2001 Dustin Graves <dgraves@computer.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

#include <string.h>
#include <cdlyte.h>
#include <fox-1.6/fx.h>
#include <fox-1.6/FXArray.h>
#include <fox-1.6/FXElement.h>
#include "CDPlayer.h"
#include "CDChoiceDialog.h"
#include "CDInfo.h"

CDInfo::CDInfo()
  : proxy(FALSE),
    cddbproto(PROTO_HTTP),
    cddbpport(CDDBP_DEFAULT_PORT),
    cddbport(HTTP_DEFAULT_PORT),
    proxyport(0),
    cddbaddr("freedb.freedb.org"),
    proxyaddr("0.0.0.0"),
    cddbexec(CDDB_HTTP_QUERY_CGI)
{
}

void CDInfo::defaultInfo(const CDPlayer& cddesc,disc_data* info)
{
  cddb_gen_unknown_entry(cddesc.getDescriptor(),info);

  FXint i,first=cddesc.getStartTrack(),total=cddesc.getNumTracks();
  strncpy(info->data_title,"Unknown Album",sizeof(info->data_title));
  strncpy(info->data_artist,"Unknown Artist",sizeof(info->data_artist));
  for(i=0;i<total;i++)
    sprintf(info->data_track[i].track_title,"Track %d",first++);
}

FXbool CDInfo::getLocalInfo(const CDPlayer& cddesc,disc_data* info)
{
  printf("Checking ~/.cddb for disc info: ");
  if(cddb_read_local("~/.cddb",cddesc.getDescriptor(),info)<0)
  {
    printf("no\n");
    defaultInfo(cddesc,info);
    return FALSE;
  }
  printf("yes\n");
  return TRUE;
}

FXbool CDInfo::getRemoteInfo(const CDPlayer& cddesc,disc_data* info,FXWindow* owner)
{
  cdsock_t sock;
  char http_string[512];
  char query_string[BUFSIZ];
  struct disc_info di;
  struct cddb_host host;
  struct cddb_hello hello;
  struct cddb_query query;
  struct cddb_server server;
  struct cddb_server *pserver=NULL;

  printf("Checking %s for disc info: ",cddbaddr.text());

  strncpy(hello.hello_program,PACKAGE,sizeof(hello.hello_program));
  strncpy(hello.hello_version,VERSION,sizeof(hello.hello_version));

  strncpy(host.host_server.server_name,cddbaddr.text(),sizeof(host.host_server.server_name));
  host.host_server.server_port=(cddbproto==PROTO_CDDBP)?cddbpport:cddbport;
  host.host_protocol=(cddbproto==PROTO_CDDBP)?CDDB_MODE_CDDBP:CDDB_MODE_HTTP;
  if(cddbproto==PROTO_HTTP) strncpy(host.host_addressing,cddbexec.text(),sizeof(host.host_addressing));

  if(proxy)
  {
    strncpy(server.server_name,proxyaddr.text(),sizeof(server.server_name));
    server.server_port=proxyport;
    pserver=&server;
  }

  sock=cddb_connect(&host,pserver,&hello,http_string,sizeof(http_string));

  if(sock!=-1)
  {
    FXint len=BUFSIZ;
    FXint result=cddb_query(cddb_query_string(cddesc.getDescriptor(),query_string,&len),sock,(cddbproto==PROTO_CDDBP)?CDDB_MODE_CDDBP:CDDB_MODE_HTTP,&query,http_string);
    if(result!=-1&&query.query_match!=QUERY_NOMATCH)
    {
      FXint choice=0;
      if(query.query_matches>1&&owner!=NULL)
      {
        CDChoiceDialog dialog(owner,&query);
        if(dialog.execute())
	  choice=dialog.getSelection();
      }

      if(cddbproto==PROTO_HTTP)
      {
        cddb_quit(sock,CDDB_MODE_HTTP);
        sock=cddb_connect(&host,pserver,&hello,http_string,sizeof(http_string));
      }

      if(sock!=-1) result=cddb_read(query.query_list[choice].list_category,query.query_list[choice].list_id,sock,(cddbproto==PROTO_CDDBP)?CDDB_MODE_CDDBP:CDDB_MODE_HTTP,info,http_string);
      else result=-1;

      cddb_quit(sock,(cddbproto==PROTO_CDDBP)?CDDB_MODE_CDDBP:CDDB_MODE_HTTP);

      if(result!=-1)
      {
        printf("yes.  Saving to ~/.cddb\n");

        cd_stat(cddesc.getDescriptor(),&di);
        //Write to the local database
        cddb_write_local("~/.cddb",&hello,&di,info,"Generated by fxcd");

        return TRUE;
      }
    }
  }
  printf("no\n");

  defaultInfo(cddesc,info);
  return FALSE;
}

FXbool CDInfo::getProxy() const
{
  return proxy;
}

void CDInfo::setProxy(FXbool use)
{
  proxy=use;
}

FXuint CDInfo::getCDDBProtocol() const
{
  return cddbproto;
}

void CDInfo::setCDDBProtocol(FXuint proto)
{
  cddbproto=proto;
}

FXushort CDInfo::getCDDBPort() const
{
  return (cddbproto==PROTO_CDDBP)?cddbpport:cddbport;
}

void CDInfo::setCDDBPort(FXushort port)
{
  if(cddbproto==PROTO_CDDBP) cddbpport=port;
  else cddbport=port;
}

FXushort CDInfo::getProxyPort() const
{
  return proxyport;
}

void CDInfo::setProxyPort(FXushort port)
{
  proxyport=port;
}

FXString CDInfo::getCDDBAddress() const
{
  return cddbaddr;
}

void CDInfo::setCDDBAddress(const FXString& addr)
{
  cddbaddr=addr;
}

FXString CDInfo::getProxyAddress() const
{
  return proxyaddr;
}

void CDInfo::setProxyAddress(const FXString& addr)
{
  proxyaddr=addr;
}

FXString CDInfo::getCDDBScript() const
{
  return cddbexec;
}

void CDInfo::setCDDBScript(const FXString& script)
{
  cddbexec=script;
}

FXbool CDInfo::getCDDBServerList(struct cddb_serverlist* list) const
{
  int sock;
  char http_string[512];
  struct cddb_host host;
  struct cddb_hello hello;
  struct cddb_server server;
  struct cddb_server *pserver=NULL;

  printf("Checking %s for disc info: ",cddbaddr.text());

  strncpy(hello.hello_program,"fxcd",sizeof(hello.hello_program));
  strncpy(hello.hello_version,"1.0.0",sizeof(hello.hello_version));

  strncpy(host.host_server.server_name,cddbaddr.text(),sizeof(host.host_server.server_name));
  host.host_server.server_port=(cddbproto==PROTO_CDDBP)?cddbpport:cddbport;
  host.host_protocol=(cddbproto==PROTO_CDDBP)?CDDB_MODE_CDDBP:CDDB_MODE_HTTP;
  if(cddbproto==PROTO_HTTP) strncpy(host.host_addressing,cddbexec.text(),sizeof(host.host_addressing));

  if(proxy)
  {
    strncpy(server.server_name,proxyaddr.text(),sizeof(server.server_name));
    server.server_port=proxyport;
    pserver=&server;
  }

  sock=cddb_connect(&host,pserver,&hello,http_string,sizeof(http_string));

  if(sock!=-1)
  {
    FXint result=cddb_sites(sock,(cddbproto==PROTO_CDDBP)?CDDB_MODE_CDDBP:CDDB_MODE_HTTP,list,http_string);
    if(result!=-1)
      return TRUE;
  }

  return FALSE;
}
